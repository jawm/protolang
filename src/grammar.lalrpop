use std::str::FromStr;
use crate::ast::expression::{
    Literal,
    Expression,
    Param,
    Return,
    AccessType,
    BinaryOperation,
    UnaryOperation
};

grammar;

pub Program: Vec<Expression> = MultipleExpr;

MultipleExpr: Vec<Expression> = <mut a: (<Expr> ";")*> <b: (<BodyRet> ";")?> => match b {
    Some(r) => {
        a.push(r);
        a
    },
    _ => a
};

BodyRet: Expression = {
    "return" <Expr>  => Expression::Return(Some(Box::new(<>))),
    "return"         => Expression::Return(None),
};

Expr: Expression = {
    Block          => Expression::Block(<>),
    <a: Assign>    => Expression::Assign(a.0.to_string(), Box::new(a.1)),
    <a: Function>  => Expression::Function(a.0, a.1, Box::new(a.2)),
    <a: IfExpr>    => Expression::If(Box::new(a.0), Box::new(a.1), a.2.map(Box::new)),
    <a: WhileExpr> => Expression::While(Box::new(a.0), Box::new(a.1)),
    <object>,
    <LogicOr>
};

Block: Vec<Expression> = "{" <MultipleExpr> "}";
Assign: (&'input str, Expression) = <Identifier> "=" <Expr>;
Function: (Vec<Param>, Option<Return>, Expression) = "fn" "(" <Comma<Param>> ")" <Return> <Expr>;
Return: Option<Return> = {
    "_" => None,
    <refLife: ("'" <Identifier>)?> "return" <b: ("'" <Identifier>)?> => Some(Return {
        lifetime: b.map(ToString::to_string),
        access_type: AccessType::Shared,
    }),
    "excl" <refLife: ("'" <Identifier>)?> "return" <b: ("'" <Identifier>)?> => Some(Return {
            lifetime: b.map(ToString::to_string),
            access_type: AccessType::Excl,
    }),
    "move return" <objLife: ("'" <Identifier>)?> => Some(Return {
        lifetime: None,
        access_type: AccessType::Move,
    }),
};
IfExpr: (Expression, Expression, Option<Expression>) = "if " <a: Expr> <b: Block> <c: ("else" <Block>)?> =>
    (a,
     Expression::Block(b),
     c.map(Expression::Block));

WhileExpr: (Expression, Expression) = "while " <a: Expr> <b: Block> => (a, Expression::Block(b));

LogicOr: Expression = {
    <a: LogicAnd> " or " <b: LogicOr> => Expression::LogicOr(Box::new(a), Box::new(b)),
    LogicAnd,
};

LogicAnd: Expression = {
    <a: Equality> " and " <b: LogicAnd> => Expression::LogicAnd(Box::new(a), Box::new(b)),
    Equality,
};

Equality: Expression       = Binary<Comparison, EqualityOp, Equality>;
Comparison: Expression     = Binary<Addition, ComparisonOp, Comparison>;
Addition: Expression       = Binary<Multiplication, AdditionOp, Addition>;
Multiplication: Expression = Binary<Unary, MultiplicationOp, Multiplication>;

Unary: Expression = {
    <a: UnaryOp> <b: Unary> => Expression::Unary {
        kind: a,
        expr: Box::new(b)
    },
    Try,
};

Try: Expression = {
    <Try> "?",
    <Call>
}

Call: Expression = {
    <a: Field> <mut b: ("(" <Comma<Expr>> ")")+ > => Expression::Call(Box::new(a), b.remove(0)),
    Field,
};

Field: Expression = <mut a: Primary> <fields: ("." <Identifier>)*> => {
    for ident in fields {
        a = Expression::FieldAccess(Box::new(a), ident.to_string());
    }
    return a;
};

Primary: Expression = {
    number,
    string,
    boolean,
    grouping,
    variable,
    "Object" => Expression::Literal(Literal::Object),
};

number: Expression = <s:r"[0-9]+"> => Expression::Literal(Literal::Integer(i64::from_str(s).unwrap()));
string: Expression = <s:r#""([^"\\]|\\.)*""#> => Expression::Literal(Literal::String(s[1..s.len()-1].to_string()));
boolean: Expression = {
    "true" => Expression::Literal(Literal::True),
    "false" => Expression::Literal(Literal::False),
};
grouping: Expression = "(" <Expr> ")" => Expression::Grouping(Box::new(<>));
variable: Expression = <Identifier> => Expression::Variable(<>.to_string());

object: Expression = <parent: LogicOr> "~" "{"
    <entries: Comma<entry>>
"}" => Expression::ObjectNew(Box::new(parent), entries) ;

entry: (String, Expression) = {
    "proto "? <a: string> ":" <b: Expr> => (a.to_string(), b),
    "proto "? <a: Identifier> ":" <b: Expr> => (a.to_string(), b),
};

Binary<A, B, C>: Expression = {
    <a: A> <b: B> <c: C> => Expression::Binary {
        kind: b,
        operands: (Box::new(a), Box::new(c)),
    },
    <A>,
};
EqualityOp: BinaryOperation = {
    "==" => BinaryOperation::Equals,
    "!=" => BinaryOperation::NotEquals,
};
ComparisonOp: BinaryOperation = {
    ">=" => BinaryOperation::GreaterOrEqual,
    "<=" => BinaryOperation::LessOrEqual,
    ">"  => BinaryOperation::GreaterThan,
    "<"  => BinaryOperation::LessThan,
};
AdditionOp: BinaryOperation = {
    "+" => BinaryOperation::Plus,
    "-" => BinaryOperation::Minus,
};
MultiplicationOp: BinaryOperation = {
    "*" => BinaryOperation::Multiply,
    "/" => BinaryOperation::Divide,
};
UnaryOp: UnaryOperation = {
    "!" => UnaryOperation::Not,
    "-" => UnaryOperation::Minus,
};

Identifier: &'input str = r"([[:alpha:]])([[:word:]])*";

Param: Param = {
    <refLife: ("'" <Identifier>)?> <a: Identifier> <objLife: ("'" <Identifier>)?> => Param {
        ident: a.to_string(),
        lifetime: objLife.map(ToString::to_string),
        access_type: AccessType::Shared,
    },
    "excl" <refLife: ("'" <Identifier>)?> <a: Identifier> <objLife: ("'" <Identifier>)?> => Param {
        ident: a.to_string(),
        lifetime: objLife.map(ToString::to_string),
        access_type: AccessType::Excl,
    },
    "move " <a: Identifier> <objLife: ("'" <Identifier>)?> => Param {
        ident: a.to_string(),
        lifetime: objLife.map(ToString::to_string),
        access_type: AccessType::Move,
    }
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};