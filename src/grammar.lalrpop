use std::str::FromStr;
use crate::ast::expression::{
    Literal,
    Expression,
    Param,
    Return,
    AccessType,
    BinaryOperation,
    UnaryOperation
};

grammar;

pub Program: Vec<Expression> = <BodyRet*>;

BodyRet: Expression = {
    "return" " " <Expr> => Expression::Return(Some(Box::new(<>))),
    "return"            => Expression::Return(None),
    Expr,
}

statement: Expression = {
    open,
    closed
};

open: Expression = {
    "if " <a: Expr> <b: statement> => Expression::If(Box::new(a), Box::new(b), None),
    "if " <a: Expr> <b: closed> "else" <c: open> => Expression::If(Box::new(a), Box::new(b), Some(Box::new(c)))
};

closed: Expression = {
    Expr,
    "if " <a: Expr> <b: closed> "else" <c: closed> => Expression::If(Box::new(a), Box::new(b), Some(Box::new(c)))
};

Expr: Expression = {
    Block          => Expression::Block(<>),
    <a: Assign>    => Expression::Assign(a.0.to_string(), Box::new(a.1)),
    Literal        => Expression::Literal(<>),
    <a: Function>  => Expression::Function(a.0, a.1, Box::new(a.2)),
    <a: IfExpr>    => Expression::If(Box::new(a.0), Box::new(a.1), a.2.map(Box::new)),
    <a: WhileExpr> => Expression::While(Box::new(a.0), Box::new(a.1)),
    <LogicOr>
};

Block: Vec<Expression> = "{" <BodyRet*> "}";
Assign: (&'input str, Expression) = <Identifier> "=" <Expr>;
Function: (Vec<Param>, Option<Return>, Expression) = "fn" "(" <Comma<Param>> ")" <Return> <Expr>;
Return: Option<Return> = {
    "_" => None,
    "return" <b: ("'" <Identifier>)?> => Some(Return {
        lifetime: b.map(ToString::to_string),
        access_type: AccessType::Shared,
    }),
    "excl return" <b: ("'" <Identifier>)?> => Some(Return {
            lifetime: b.map(ToString::to_string),
            access_type: AccessType::Excl,
    }),
    "move return" => Some(Return {
        lifetime: None,
        access_type: AccessType::Move,
    }),
};
IfExpr: (Expression, Expression, Option<Expression>) = "if " <a: Expr> <b: Block> <c: ("else" <Block>)?> =>
    (a,
     Expression::Block(b),
     c.map(Expression::Block));

WhileExpr: (Expression, Expression) = "while " <Expr> <Expr>;

LogicOr: Expression = {
    <a: LogicAnd> " or " <b: LogicOr> => Expression::LogicOr(Box::new(a), Box::new(b)),
    LogicAnd,
};

LogicAnd: Expression = {
    <a: Equality> " and " <b: LogicAnd> => Expression::LogicAnd(Box::new(a), Box::new(b)),
    Equality,
};

Equality: Expression       = Binary<Comparison, EqualityOp, Equality>;
Comparison: Expression     = Binary<Addition, ComparisonOp, Comparison>;
Addition: Expression       = Binary<Multiplication, AdditionOp, Addition>;
Multiplication: Expression = Binary<Unary, MultiplicationOp, Multiplication>;

Unary: Expression = {
    <a: UnaryOp> <b: Unary> => Expression::Unary {
        kind: a,
        expr: Box::new(b)
    },
    //Call
}

//Call: Expresion =


Binary<A, B, C>: Expression = {
    <a: A> <b: B> <c: C> => Expression::Binary {
        kind: b,
        operands: (Box::new(a), Box::new(c)),
    },
    <A>,
};
EqualityOp: BinaryOperation = {
    "==" => BinaryOperation::Equals,
    "!=" => BinaryOperation::NotEquals,
};
ComparisonOp: BinaryOperation = {
    ">=" => BinaryOperation::GreaterOrEqual,
    "<=" => BinaryOperation::LessOrEqual,
    ">"  => BinaryOperation::GreaterThan,
    "<"  => BinaryOperation::LessThan,
};
AdditionOp: BinaryOperation = {
    "+" => BinaryOperation::Plus,
    "-" => BinaryOperation::Minus,
};
MultiplicationOp: BinaryOperation = {
    "*" => BinaryOperation::Multiply,
    "/" => BinaryOperation::Divide,
};
UnaryOp: UnaryOperation = {
    "!" => UnaryOperation::Not,
   // "-" => UnaryOperation::Minus,
};


Identifier: &'input str = r"([[:alpha:]])([[:word:]])*";

Literal: Literal = "5" => Literal::False;

Param: Param = {
    <a: Identifier> <b: ("'" <Identifier>)?> => Param {
        ident: a.to_string(),
        lifetime: b.map(ToString::to_string),
        access_type: AccessType::Shared,
    },
    "excl " <a: Identifier> <b: ("'" <Identifier>)?> => Param {
        ident: a.to_string(),
        lifetime: b.map(ToString::to_string),
        access_type: AccessType::Excl,
    },
    "move " <Identifier> => Param {
        ident: <>.to_string(),
        lifetime: None,
        access_type: AccessType::Move,
    }
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};